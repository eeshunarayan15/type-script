npm install -g typescipt ---> comman to install the typescritp globally

then create the java-script project using this command
--->        npm init -y

command to create the tsConfig.json
npx tsc --init

now install the npm packages using this command

---->  npm install

command to compile ths typescript file into javascript
---> npx tsc -b


tsconfig.json â†’ target option
The "target" option in tsconfig.json tells TypeScript which version of JavaScript to compile your code into.

âœ… Syntax:
json
Copy
Edit
{
  "compilerOptions": {
    "target": "ES2020"
  }
}

ğŸ”§ 1. rootDir
ğŸ“Œ What it does:
Specifies the source folder where your .ts files live.

âœ… Example:
json
Copy
Edit
{
  "compilerOptions": {
    "rootDir": "./src"
  }
}
ğŸ“ Folder structure:

pgsql
Copy
Edit
project/
â”œâ”€â”€ src/          <-- TypeScript source files
â”‚   â””â”€â”€ app.ts
â”œâ”€â”€ dist/         <-- Compiled JavaScript goes here
â””â”€â”€ tsconfig.json
This tells TypeScript: â€œOnly look for .ts files starting from src/â€.

ğŸ”§ 2. outDir
ğŸ“Œ What it does:
Specifies where the compiled .js files should go.

âœ… Example:
json
Copy
Edit
{
  "compilerOptions": {
    "outDir": "./dist"
  }
}
TypeScript takes files from rootDir, compiles them, and puts the result in outDir.

ğŸ’¥ 3. noImplicitAny
ğŸ“Œ What it does:
If true, TypeScript will show an error if a variable or function argument has no type and TypeScript has to guess it as any.

json
Copy
Edit
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
âœ… Good:
ts
Copy
Edit
function greet(name: string) {
  console.log("Hello", name);
}
âŒ Error with noImplicitAny: true:
ts
Copy
Edit
function greet(name) {
  console.log("Hello", name);
  // Error: Parameter 'name' implicitly has an 'any' type.
}
In TypeScript, intersection types allow you to combine multiple types into one. This means the resulting type will have all the properties of the intersected types.
ğŸ”§ Syntax

type A = { x: number };
type B = { y: number };

type C = A & B; // C is { x: number, y: number }

âœ… Example: Combining Two Types

type Person = { name: string };
type Employee = { id: number };

type Staff = Person & Employee;

const worker: Staff = {
  name: "Alice",
  id: 123
};

âš ï¸ Optional and Conflicting Fields

TypeScript will merge optional fields or flag conflicts:

type A = { x: number };
type B = { x: string }; // Conflict: same key, different type

type C = A & B; // Error: Type 'number' is not assignable to type 'string'

ğŸ§  Use Cases

    Creating complex types by combining smaller ones

    Adding extra information to existing types

    Working with React props, API responses, etc.

âœ… Real Example: Merging Geometry Types

type Point = { x: number, y: number };
type Named = { name: string };

type LabeledPoint = Point & Named;

const p: LabeledPoint = {
  x: 5,
  y: 10,
  name: "Origin"
};

Would you like a visual diagram for this as well?
You said:
use case and real word use of intersection
ChatGPT said:

Great question â€” understanding real-world use cases of intersection types in TypeScript helps you write cleaner, more expressive code, especially in large codebases.
âœ… Real-World Use Cases of Intersection (&) in TypeScript
1. Extending Object Types (e.g., Models, Entities)

Suppose you have reusable building blocks for different entities in an app:

type Timestamps = {
  createdAt: Date;
  updatedAt: Date;
};

type User = {
  id: number;
  name: string;
};

type UserWithTimestamps = User & Timestamps;

ğŸ’¡ Use case: Adds metadata (timestamps) to base entities in a database model, without duplicating code.
2. React Props Composition

React components often take in multiple props that can be defined separately and reused:

type ButtonProps = {
  label: string;
  onClick: () => void;
};

type StyleProps = {
  className?: string;
};

type FullButtonProps = ButtonProps & StyleProps;

const MyButton: React.FC<FullButtonProps> = ({ label, onClick, className }) => (
  <button className={className} onClick={onClick}>
    {label}
  </button>
);

ğŸ’¡ Use case: Composing UI props for modular components.
3. Combining API Response Data

type User = { id: number; name: string };
type Permissions = { roles: string[] };

type AuthenticatedUser = User & Permissions;

function getCurrentUser(): AuthenticatedUser {
  return {
    id: 1,
    name: "Harkirat",
    roles: ["admin", "editor"],
  };
}

ğŸ’¡ Use case: Combines user identity and permissions into one type for authentication.
4. Middleware Enhancements in Express.js

In Express apps, you might enhance the Request object with custom fields:

import { Request } from "express";

type AuthPayload = {
  userId: string;
};

type AuthenticatedRequest = Request & { auth: AuthPayload };

function authMiddleware(req: AuthenticatedRequest, res, next) {
  req.auth = { userId: "abc123" };
  next();
}

ğŸ’¡ Use case: Inject custom data into existing libraries' types (middleware, plugin patterns, etc.)
5. Form Validation + Meta Info

type FormFields = {
  email: string;
  password: string;
};

type Meta = {
  isValid: boolean;
};

type ValidatedForm = FormFields & Meta;

ğŸ’¡ Use case: Attaching validation state to data types, useful in frontend forms.