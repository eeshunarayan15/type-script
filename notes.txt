npm install -g typescipt ---> comman to install the typescritp globally

then create the java-script project using this command
--->        npm init -y

command to create the tsConfig.json
npx tsc --init

now install the npm packages using this command

---->  npm install

command to compile ths typescript file into javascript
---> npx tsc -b


tsconfig.json → target option
The "target" option in tsconfig.json tells TypeScript which version of JavaScript to compile your code into.

✅ Syntax:
json
Copy
Edit
{
  "compilerOptions": {
    "target": "ES2020"
  }
}

🔧 1. rootDir
📌 What it does:
Specifies the source folder where your .ts files live.

✅ Example:
json
Copy
Edit
{
  "compilerOptions": {
    "rootDir": "./src"
  }
}
📁 Folder structure:

pgsql
Copy
Edit
project/
├── src/          <-- TypeScript source files
│   └── app.ts
├── dist/         <-- Compiled JavaScript goes here
└── tsconfig.json
This tells TypeScript: “Only look for .ts files starting from src/”.

🔧 2. outDir
📌 What it does:
Specifies where the compiled .js files should go.

✅ Example:
json
Copy
Edit
{
  "compilerOptions": {
    "outDir": "./dist"
  }
}
TypeScript takes files from rootDir, compiles them, and puts the result in outDir.

💥 3. noImplicitAny
📌 What it does:
If true, TypeScript will show an error if a variable or function argument has no type and TypeScript has to guess it as any.

json
Copy
Edit
{
  "compilerOptions": {
    "noImplicitAny": true
  }
}
✅ Good:
ts
Copy
Edit
function greet(name: string) {
  console.log("Hello", name);
}
❌ Error with noImplicitAny: true:
ts
Copy
Edit
function greet(name) {
  console.log("Hello", name);
  // Error: Parameter 'name' implicitly has an 'any' type.
}
In TypeScript, intersection types allow you to combine multiple types into one. This means the resulting type will have all the properties of the intersected types.
🔧 Syntax

type A = { x: number };
type B = { y: number };

type C = A & B; // C is { x: number, y: number }

✅ Example: Combining Two Types

type Person = { name: string };
type Employee = { id: number };

type Staff = Person & Employee;

const worker: Staff = {
  name: "Alice",
  id: 123
};

⚠️ Optional and Conflicting Fields

TypeScript will merge optional fields or flag conflicts:

type A = { x: number };
type B = { x: string }; // Conflict: same key, different type

type C = A & B; // Error: Type 'number' is not assignable to type 'string'

🧠 Use Cases

    Creating complex types by combining smaller ones

    Adding extra information to existing types

    Working with React props, API responses, etc.

✅ Real Example: Merging Geometry Types

type Point = { x: number, y: number };
type Named = { name: string };

type LabeledPoint = Point & Named;

const p: LabeledPoint = {
  x: 5,
  y: 10,
  name: "Origin"
};

Would you like a visual diagram for this as well?
You said:
use case and real word use of intersection
ChatGPT said:

Great question — understanding real-world use cases of intersection types in TypeScript helps you write cleaner, more expressive code, especially in large codebases.
✅ Real-World Use Cases of Intersection (&) in TypeScript
1. Extending Object Types (e.g., Models, Entities)

Suppose you have reusable building blocks for different entities in an app:

type Timestamps = {
  createdAt: Date;
  updatedAt: Date;
};

type User = {
  id: number;
  name: string;
};

type UserWithTimestamps = User & Timestamps;

💡 Use case: Adds metadata (timestamps) to base entities in a database model, without duplicating code.
2. React Props Composition

React components often take in multiple props that can be defined separately and reused:

type ButtonProps = {
  label: string;
  onClick: () => void;
};

type StyleProps = {
  className?: string;
};

type FullButtonProps = ButtonProps & StyleProps;

const MyButton: React.FC<FullButtonProps> = ({ label, onClick, className }) => (
  <button className={className} onClick={onClick}>
    {label}
  </button>
);

💡 Use case: Composing UI props for modular components.
3. Combining API Response Data

type User = { id: number; name: string };
type Permissions = { roles: string[] };

type AuthenticatedUser = User & Permissions;

function getCurrentUser(): AuthenticatedUser {
  return {
    id: 1,
    name: "Harkirat",
    roles: ["admin", "editor"],
  };
}

💡 Use case: Combines user identity and permissions into one type for authentication.
4. Middleware Enhancements in Express.js

In Express apps, you might enhance the Request object with custom fields:

import { Request } from "express";

type AuthPayload = {
  userId: string;
};

type AuthenticatedRequest = Request & { auth: AuthPayload };

function authMiddleware(req: AuthenticatedRequest, res, next) {
  req.auth = { userId: "abc123" };
  next();
}

💡 Use case: Inject custom data into existing libraries' types (middleware, plugin patterns, etc.)
5. Form Validation + Meta Info

type FormFields = {
  email: string;
  password: string;
};

type Meta = {
  isValid: boolean;
};

type ValidatedForm = FormFields & Meta;

💡 Use case: Attaching validation state to data types, useful in frontend forms.